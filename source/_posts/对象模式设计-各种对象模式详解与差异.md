  

### o **各种对象模式详解与差异**

#####  **设计对象模式的意义**

  所需要的实例对象通过构造函数获得私有属性、通过原型链获得共享的属性。

  什么是好的方式？

  私有属性通过构造函数的方式获得（不考虑实例中自定义私有属性）且不需要重写，共享属性通过原型链找到且不需要重复创建。

资料：https://segmentfault.com/a/1190000004559437


#####  **工厂模式**
#### 工厂模式 

    // 在函数内创建一个对象，能够根据接收的参数来构建一个包含所有必要信息的Person对象
         function createPerson(name, age) {
           let Person = new Object();
           Person.name = name;
           Person.age = age;
        return Person;
         }
           let person1 = createPerson("Lily", 29);
           let person2 = createPerson("Ming", 28);
           console.log(person1.name + person1.age);
           console.log(person2.name + person2.age);


工厂模式解决了创建多个相似对象的问题。

缺点：没有解决对象识别的问题（无法知道对象的类型）



##### **构造函数**



优点:可以将构造函数的实例表示为一种特定类型

![](//:0)

构造函数的用法：

构造函数与其他函数的区别**只是调用的方式不同**。

 1.当做构造函数使用

   \***所有函数，只要调用的时候通过new操作符来调用，就可以作为构造函数。否则就是普通函数。**

![](//:0)

2.当做普通函数调用

   **\*当在全局作用域中调用一个函数，this对象指向window。window对象下就会拥有调用的那个函数的所有属性与方法。**所以在这里window对象就会有sayName方法

![](//:0)

3.在另一个对象的作用域中调用

![](//:0)

new一个构造函数，如果构造函数没有返回值，会隐式的把this作为返回值

##### **new一个构造函数的本质**

**如果构造函数没有返回值，会先创建一个指向构造函数原型对象的空对象，this会作为一个默认的返回值，在js底层进行隐式转换的时候，空对象会作为执行环境,this将会作为传参**

    **let person=new Person()        ==        new Person().apply(person,this)**

    **有点类似于上面这种，个人理解不一定对**

**从而生成一个拥有构造函数属性同时\_\_proto\_\_又指向了构造函数.prototype的新对象**

![](//:0)

**如果构造函数有返回值，返回的是对象（不包括null）和函数，则返回值为对象，否则返回的还是默认的this对象**

![](//:0)

构造函数缺点：

在构造函数中创建的每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数是不相等的。

![](//:0)

 解决多次创造函数实例的办法：把函数定义转移到构造函数外部。

![](//:0)

 但是一样有对象如果有多个方法就需要定义多个全局函数的弊端，没有封装性可言。

##### **构造函数与工厂模式的区别**

构造函数：

1.没有显示的创建对象

2.直接将属性和方法赋给了this对象

3.没有return语句

4.实例可以标识为一种特定的类型

   例如 let person1=new Person(); person1 instanceof Person //true

##### **原型模式**

每个函数都有一个prototype属性，（**Function与Object都是js自带函数，所有他们都有prototype**）prototype属性是一个指针，指向了函数的原型对象。**实例对象没有原型对象,Object是因为是js自带的函数所以才有原型对象。**

可以对原型对象设定属性和方法，可以让对象实例进行共享。

优势：对比构造函数来说不必在构造函数中定义对象的实例信息。既不会每次实例化对象都创建一个实例函数也不会为了避免创建多个实例函数而放在全局，从而失去了封装性。

原型模式执行过程：

![](//:0)

###### **1.理解原型对象**

l 每个函数拥有一个原型对象,函数通过prototype找到原型对象。

l 函数的实例对象通过隐式属性\_\_proto\_\_找到这个原型对象。

l 原型对象有一个默认属性constructor，指向函数

![](//:0)

###### **2.原型模式的搜寻方式**

l  解析器在寻找属性和方法的时候会优先寻找实例上的属性和方法，如果能找到则不会再去搜寻原型对象。

![](//:0)

###### **3.判断一个属性存在于实例上还是存在于原型对象上**

"属性" in Object ：用来判断 这个属性是否存在于对象上，无论是实例还是原型对象都为true

Object hasOwnProperty("属性"):用来判断属性是否在实例上，在实例上则为true

结合两者:

!object.hasOwnProperty(name) && name in object：判断是否在原型上

![](//:0)

###### **4.获取原型对象上属性的方法**

![](//:0)

###### **5.使用字面量方法定义原型对象**

    使用字面量相当于创建了一个新的原型对象，会与原有的原型对象共存，但是要注意创建实例的位置与原型对象的关系。

![](//:0)

###### **6.原型模式的缺点**

原型中的属性都是被共享的，所以实例中修改引用类型的值，同时也会修改掉原型对象中引用类型的值。

![](//:0)

##### **组合模式（构造函数模式+原型模式）**

 构造模式用于定义实例属性

 原型模式用于定义方法和共享属性（不能是引用类型的属性）

 结果，每个实例都有一份实例属性的副本同时又共享着方法，最大限度的节省内存。另外这种混合模式还支持向构造函数传递参数

![](//:0)

###### **动态原型**

 1.把所有信息封装在了构造函数中。

 2.通过在构造函数中初始化原型，保持了构造函数和原型的优点。

 换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型

注意：这段代码只会在初次调用构造函数中执行

![](//:0)

##### **寄生构造函数模式**

    寄生模式使用new操作符去实例化对象，其余跟工厂模式一致。

    寄生模式也不能识别对象类型，这点也与工厂模式一致。

![](//:0)

 使用寄生构造函数的目的是希望扩展原生Array的一个方法toPipeMessage,为了不污染原生构造函数。相当于作者希望通过new去区分，**用寄生构造去定义扩展原生函数，用工厂模式去定义自定义函数。**

资料：https://segmentfault.com/q/1010000004596650

##### **稳妥构造函数模式**

 遵循类似寄生构造函数的模式。稳妥构造函数模式也不能识别对象类型。

 稳妥对象适合在一些安全的环境中（这些环境禁止使用this或者new），或者在防止数据被其他应用程序改动时使用。

![](//:0)